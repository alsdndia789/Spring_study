# Spring_study
인터페이스 InitializingBean, DisposableBean
------------
InitializingBean 은 afterPropertiesSet() 메서드로 초기화를 지원한다. DisposableBean 은 destroy() 메서드로 소멸을 지원한다.

빈 등록 초기화, 소멸 메서드
------------
 메서드 이름을 자유롭게 줄 수 있다.

스프링 빈이 스프링 코드에 의존하지 않는다.

코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.

애노테이션 @PostConstruct, @PreDestory
------------
@PostConstruct, @PreDestroy 애노테이션 특징 최신 스프링에서 가장 권장하는 방법.

.애노테이션 하나만 붙이면 된다.

스프링이 아닌 다른 컨테이너에서도 동작한다.

단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면 @Bean 사용

빈 스코프
빈 스코프란?
------------
스코프는 번역 그대로 빈이 존재할 수 있는 범위를 뜻한다.

싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프

프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프

웹 관련 스코프 request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프

session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프

application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프.

프로토타입 스코프
------------
프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.

스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다

프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있어서 @PreDestroy 같은 종료 메서드가 호출되지 않는다.

프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
------------
싱글톤 빈이 프로토타입 빈을 사용하게 된다. 그런데 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, 프로토타입 빈이 새로 생성되기는 하지만, 싱글톤 빈과 함께 계속 유지된다.

프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결
------------
싱글톤 빈이 프로토타입을 사용할 때 마다 스프링 컨테이너에 새로 요청하는 방법.

ObjectFactory, ObjectProvider 지정한 빈을 컨테이너에서 대신 찾아주는 DL( 의존관계 조회) 서비스를 제공한다.

웹 스코프
------------
웹 스코프는 웹 환경에서만 동작한다.

웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다.

 웹 스코프 종류

request: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.

session: HTTP Session과 동일한 생명주기를 가지는 스코프

application: 서블릿 컨텍스트( ServletContext )와 동일한 생명주기를 가지는 스코프

websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프

request 스코프 예제 만들기
------------
implementation 'org.springframework.boot:spring-boot-starter-web'

동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어려울 때 request scope 를 사용한다.

스코프와 Provider
------------
ObjectProvider를 사용하여 ObjectProvider.getObject() 를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.

스코프와 프록시
------------
proxyMode = ScopedProxyMode.TARGET_CLASS

적용 대상이 인터페이스가 아닌 클래스면 TARGET_CLASS, 적용 대상이 인터페이스면 INTERFACES

싱글톤과는 다르게 동작하기 때문에 결국 주의해서 사용해야 한다. 유지보수 하기가 어려워지기 때문에 꼭 필요한 곳에만 최소화해서 사용하자,
